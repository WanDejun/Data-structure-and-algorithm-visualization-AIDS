# 数据结构与算法可视化辅助程序(Data structure and algorithm visualization AIDS) #

### （本项目只采用了c++中的bool类型，函数重载两个特性，未采用面向对象思想编写。是一个c风格的cpp程序？）
- ps.截至2023.11.18 0:20 该项目已有1548行代码
- ps.截至2023.11.22 15:54 已有3401行代码

### 主界面 ###
- 采用ui进行跳转至每个子模块
- 窗口分辨率采用 1280 * 720px

### 排序部分 ###
- 冒泡
- 插入
- 选择
- 快排
- 堆排序(与堆数据结构一起做)
- 二分查找(与树的数据结构一起做)

### 数据结构部分 ###
- 链表(插入，删除)
- 栈(push, pop) (最简单)
- 队列(push, pop)
- 树(二分查找， 遍历)

### 主要开发思想 ###
- 将画面中的每个图形抽象成一组结构体数组(没有oop的悲哀)， 通过修改结构体的某个元素即可完成对画面的修改
- 每个功能定义function_main()函数用于控制算法过程，和function_draw()函数用于控制绘图

### 主要函数模块 ###
- 绘制箭头 箭头结构体数组(draw_arrow.h)
- 控制文本输出 文本结构体数组(textout.h)
- 控制方框输出（draw_rect.h）
- 灰度计算函数 （gray.h）
- 随机颜色生成函数（rand_color.h）
- (可选，视情况开发) (已完成) 数据结构执行过程中由用户输入控制执行流(原本为随机数输入)，开发输入控制台 （input_box.h）
- 链表部分（link.h(调用了link_insert_delete.h)）
- 排序的交换可视化模块

## 详细部分 ##

### 链表 (link.h)
- 主界面三个控制按钮（insert, delete, quit）， 决定程序流走向
- 采用link_insert_main(), 和link_delete_main()作为程序的主入口
- link_draw()为主输出函数， 其余为对其的派生
- 占用了3个text_set[]空间，分别用于保存快慢指针， 和运行状态的提示（左上角）
- 插入分为以下过程  
1. 寻找节点的插入位置
1. 插入位置后方的指针后移（箭头伸长）
1. 插入节点淡入
1. 链接4根指针
1. 插入节点下移完成插入过程

- 删除分为以下过程
1. 寻找待删除的节点
1. 待删除节点上移
1. 链接前后节点
1. 删除插入节点
1. 后方节点前移

- 过程结束之后释放内存空间

## 栈 （数组表示） (stack.h) ##
- 将方格和文字封装用来表示节点
- 每个节点的坐标，在初始化时预先定义
- 节点压入栈时渐入，下移， 新增节点采用颜色随机函数，并计算灰度值，用以确定其中文字的颜色
- 出栈时上移，渐入

## 栈 （链表表示） （stack_by_link.h） ##
- 将上面二者有机结合

## 环形队列 (cycle_link.h) ##
- 采用环形ui
- 坐标在数据结构中采用极坐标表示（与y负方向的夹角，即与屏幕上方的夹角），在输出函数中再转化至直角坐标系
- 与栈采用同款随机颜色
- 左侧有头尾指针下标提示输出

## 队列 (queue_by_link.h) ##
- 初始头尾节点均指向null节点
- 插入值时，判断溢出（人为设置最大为7个），null节点后移，tail->next = malloc（sizeof node），产生新的可视化节点。	
1. 若原本队列为空，则头尾指针都需要从null上修改为新增节点，可视化上表现为：新增的可视化节点
在0号位置，因此尾指针无需后移。
1. 若原本队列不为空，则尾指针需要后移。
- 删除值时，判断队列为空报错。
1. 若删除后的队列不为空，头结点后移，原本队头节点释放，可视化上表现为淡出，所有队列的实例前移
1. 若删除后的队列为空，则只前移null节点
## 堆（优先队列）（heap.h） ##
- adjust（堆的核心操作），自上而下调整节点顺序，使堆序维持
- 树形结构插入时考虑树枝和节点的横向（x方向)舒展 （可视化主程序中目前堆被限制在了3层，
因此只有第二层需要调整）
- 插入时，考虑节点数溢出，当插入第（1 << n）（n >= 2）个节点时,
要将第i（1 < i < n）层舒展（stretch）
- 插入在尾部，自下向上做adjust
- 删除时考虑空堆错误，删除的节点在头部，删完之后将尾部节点赋值到头部，删除尾部节点
- 当删除第（1 << n）（n >= 2）个节点时,要将第i（1 < i < n）层收缩（shrink）
